package cluster

import (
	"encoding/json"
	"fmt"

	"gopkg.in/yaml.v2"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	clientcmdapiv1 "k8s.io/client-go/tools/clientcmd/api/v1"
	sigyaml "sigs.k8s.io/yaml"
)

const (
	k8sUser = "user"
)

// Credentials interface manages all cluster related tasks
type Credentials interface {
	ToRestConfig() (*rest.Config, error)
}

// K8sClusterCreds implements CredsManager interface
type K8sClusterCreds struct {
	K8sConfig *K8sConfig
}

// NewK8sClusterCreds returns a K8sCredsManager
func NewK8sClusterCreds(k *K8sConfig) *K8sClusterCreds {
	return &K8sClusterCreds{K8sConfig: k}
}

// K8sConfig contains fields on how to connect to a k8s cluster
type K8sConfig struct {
	Cluster  *clientcmdapiv1.Cluster  `json:"cluster" yaml:"cluster"`
	AuthInfo *clientcmdapiv1.AuthInfo `json:"user" yaml:"user" mapstructure:"user"`
	Name     string                   `json:"name" yaml:"name"`
}

// UnmarshalYAML implements Unmarshal interface
// Since K8sConfig fields only have json tags, sigyaml.Unmarshal needs to be used
// to unmarshal all the fields. This method reads K8sConfig into a map[string]interface{},
// marshals it into a byte for, before passing to sigyaml.Unmarshal
func (k *K8sConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var kubeconfig map[string]interface{}
	// Unmarshal into map[string]interface{}
	if err := unmarshal(&kubeconfig); err != nil {
		return err
	}
	// convert back to byte string
	byteForm, err := yaml.Marshal(kubeconfig)
	if err != nil {
		return err
	}
	// use sigyaml.Unmarshal to convert to json object then unmarshal
	if err := sigyaml.Unmarshal(byteForm, k); err != nil {
		return err
	}
	return nil
}

// Decode provides envconfig steps to parse env var to K8sConfig struct
func (k *K8sConfig) Decode(value string) error {
	var k8sConfig K8sConfig
	if err := json.Unmarshal([]byte(value), &k8sConfig); err != nil {
		return err
	}
	*k = k8sConfig
	return nil
}

// ToRestConfig generates a k8s rest.Config that is used to instantiate k8s clients
// ie any client that is generated by client-go generators
func (k *K8sClusterCreds) ToRestConfig() (*rest.Config, error) {
	restConf := generateKubeConfig(k.K8sConfig)
	r, err := sigyaml.Marshal(restConf)
	if err != nil {
		return nil, err
	}
	cfg, err := clientcmd.RESTConfigFromKubeConfig(r)
	if err != nil {
		return nil, err
	}
	return cfg, nil
}

func generateKubeConfig(c *K8sConfig) *clientcmdapiv1.Config {
	return &clientcmdapiv1.Config{
		Clusters: []clientcmdapiv1.NamedCluster{
			{
				Name:    c.Name,
				Cluster: *c.Cluster,
			},
		},
		AuthInfos: []clientcmdapiv1.NamedAuthInfo{
			{
				Name:     k8sUser,
				AuthInfo: *c.AuthInfo,
			},
		},
		Contexts: []clientcmdapiv1.NamedContext{
			{
				Name: fmt.Sprintf("%s-%s", c.Name, k8sUser),
				Context: clientcmdapiv1.Context{
					Cluster:  c.Name,
					AuthInfo: k8sUser,
				},
			},
		},
		CurrentContext: fmt.Sprintf("%s-%s", c.Name, k8sUser),
	}
}
